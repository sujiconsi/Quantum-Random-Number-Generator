# Quantum Random Number Generator


Unlike classical random generators (which are ultimately predictable algorithms), our quantum circuit uses the randomness of measurement outcomes to produce numbers that are fundamentally unpredictable.

We built this using Qiskit Runtime v2, and our design shows how quantum randomness can be measured, tested for fairness, and even applied to something useful: secure password generation.

## Why We Built It

Every system today relies on randomness (for passwords, encryption keys, and simulations).
But most “random” numbers generated by classical computers are pseudorandom: produced by deterministic algorithms that only appear random. Given the seed, their entire sequence can be predicted.
Superposition of qubits, however, means their measurement results are fundamentally uncertain, quantum circuits can act as true random number generators (QRNGs).

Our goal:
1. Create a fair quantum random number generator (QRNG)
2. Prove that the results are genuinely uniform
3. Apply it to generate high-entropy passwords
4. Explore how noise mitigation can make it even fairer
χ² = Σ((Observed - Expected)² / Expected)


## How It Works
### 1. Generating Quantum Random Numbers
We build an n-qubit circuit and apply Hadamard (H) gates to each qubit, creating an equal superposition.
For n qubits, that gives 2ⁿ possible outcomes — all ideally equally likely.

Example:
<img src="https://latex.codecogs.com/svg.image?\bg_white%20%7C0%5Crangle%20%5Cstackrel%7BH%7D%7B%5Clongrightarrow%7D%20%7C%2B%5Crangle%20=%20%5Cfrac%7B%7C0%5Crangle%20+%20%7C1%5Crangle%7D%7B%5Csqrt%7B2%7D%7D" alt="Hadamard transformation" />

Each measurement (e.g., 1010) can be interpreted as a random integer (10 in decimal).
Running many shots produces a distribution that should look uniform.

(Inspired by IBM’s open-source Qiskit RNG framework:https://github.com/qiskit-community/qiskit_rng) We used the same low-depth superposition circuits for efficiency.

### 2. Visualizing and Testing Fairness
By running many “shots,” we see how evenly each outcome appears.
Ideally, all outcomes should have the same frequency, forming a flat histogram.

We attempt to test the randomness of our results through:
* Chi-Square (X²) Test
compares the measured counts of each outcome with what we would expect in a perfectly uniform distribution.
<img src="https://latex.codecogs.com/svg.image?\bg_white%20%5Cchi%5E2%20=%20%5Csum%20%5Cfrac%7B(Observed-Expected)%5E2%7D%7BExpected%7D" alt="Chi-square formula" />
If the X² value is small (close to 0), the distribution is close to uniform.
This method follows the NIST randomness test suite used. (inspired by step 4 of https://github.com/dorahacksglobal/quantum-randomness-generator/tree/QC-Prediction-Model)

* Bit-Frequency Analysis
We count how often 0 and 1 appear across all measurements.
True randomness should give roughly 50% zeros and 50% ones — any large imbalance signals bias.

### 3. Mitigating Noise 

Real quantum devices aren’t perfect: some values appear slightly more often.

We calibrate a readout-error matrix and apply a simple correction, this evens out the histogram and demonstrates a “fairer” random generator.

### 4. Password Mode

Using quantum bits as a source, we randomly sample letters, digits, and symbols to form secure passwords.
Each password is unpredictable and uniformly distributed — ideal for cryptography or logins.
