# Quantum Random Number Generator (for Random Password Generation)

Full name: Wei Chan Leong 

email ID: lwc.wei.chan@gmail.com

A short note describing your experience running the notebook:
- Qiskit Version and Package Compatibility (some packages dont work well with Qiskit 2.0 (had to get older version of Qiskit to run))

Let us know if you’d like mentorship or guidance to learn more about Qiskit and quantum computing:
- I would be keen to receive mentorship on Qiskit, new quantum algorithms and in noise modeling and practical circuit optimization.

----

Unlike classical random generators (which are ultimately predictable algorithms), our quantum circuit uses the randomness of measurement outcomes to produce numbers that are fundamentally unpredictable.

We built this using Qiskit Runtime v2, and our design shows how quantum randomness can be measured, tested for fairness, and even applied to something useful: secure password generation.

## A. Purpose/ Goals

Every system today relies on randomness (for passwords, encryption keys, and simulations).
But most “random” numbers generated by classical computers are pseudorandom: produced by deterministic algorithms that only appear random. Given the seed, their entire sequence can be predicted.

Superposition of qubits, however, means their measurement results are fundamentally uncertain, quantum circuits can act as true random number generators (QRNGs) (Herrero-Collantes & García-Escartín, 2017).

Our goal:
1. Create a fair quantum random number generator (QRNG)
2. Prove that the results are genuinely uniform
3. Apply it to generate high-entropy passwords
4. Explore how noise mitigation can make it even fairer
χ² = Σ((Observed - Expected)² / Expected) (χ² formula from NIST, 2010).


## B. Respository Structure/ Documents

```text
qrng-plus/
├─ src/
│  ├─ qrng.py              # Core Hⁿ circuit + bit cache + uniform ints
│  ├─ quantum_passwords.py # Convert bits → printable Base94 passwords
│  ├─ metrics.py           # χ², KL, bit-frequency, histograms
│  ├─ mitigation.py        # Readout calibration & correction (optional)
│  ├─ lgi_cert.py          # LGI + NSIT certification protocol
│  └─ viz.py               # Matplotlib plotting helpers
├─ notebooks/
│  └─ QRNGpp_demo.ipynb    # Main step-by-step demo (A–H)
└─ data/                   # Auto-created cache for results & plots
```


## B1: Key Dependencies
- **Qiskit** – circuit construction & simulation (`qiskit`, `qiskit-runtime`, if unable to use Qiskit Runtime: `qiskit-aer`)
- **NumPy** – numerical arrays & probability vectors
- **SciPy** – chi-square test statistics
- **Matplotlib** – plots & figures
- **JSON / pathlib** – structured caching of counts & metrics

### B2: Workflow (Notebook Sections A–H)
| Section | Description |
|----------|-------------|
| **A** | Setup environment & create `data/` folder |
| **B** | Generate raw bitstrings using Hⁿ + measurement |
| **C** | Visualize counts and bit-frequency |
| **D** | Statistical tests (χ², KL divergence) |
| **E** | Readout-error mitigation and re-evaluation |
| **F** | LGI + NSIT certification (temporal quantum tests) |
| **G** | Password generator & entropy analysis |
| **H** | Save metadata for reproducibility |


# C. How It Works
## 1. Generating Quantum Random Numbers
We build an n-qubit circuit and apply Hadamard (H) gates to each qubit, creating an equal superposition.
For n qubits, that gives 2ⁿ possible outcomes — all ideally equally likely.

Example:

<img src="https://latex.codecogs.com/svg.image?\bg_white%20%7C0%5Crangle%20%5Cstackrel%7BH%7D%7B%5Clongrightarrow%7D%20%7C%2B%5Crangle%20=%20%5Cfrac%7B%7C0%5Crangle%20+%20%7C1%5Crangle%7D%7B%5Csqrt%7B2%7D%7D" alt="Hadamard transformation" />

Each measurement (e.g., 1010) can be interpreted as a random integer (10 in decimal).
Running many shots produces a distribution that should look uniform.

Inspired by IBM’s open-source Qiskit RNG framework (qiskit-community/qiskit_rng) and prior theoretical work (Herrero-Collantes & García-Escartín, 2017):
We used the same low-depth superposition circuits for efficiency.

## 2. Visualizing and Testing Fairness
By running many “shots,” we see how evenly each outcome appears.
Ideally, all outcomes should have the same frequency, forming a flat histogram.

We attempt to test the randomness of our results through:

### * Chi-Square (X²) Test

Compares the measured counts of each outcome with what we would expect in a perfectly uniform distribution.

<img src="https://latex.codecogs.com/svg.image?\bg_white%20%5Cchi%5E2%20=%20%5Csum%20%5Cfrac%7B(Observed-Expected)%5E2%7D%7BExpected%7D" alt="Chi-square formula" />

If the X² value is small (close to 0), the distribution is close to uniform.
This method follows the NIST randomness test suite used (NIST, 2010). (also inspired by step 4 of https://github.com/dorahacksglobal/quantum-randomness-generator/tree/QC-Prediction-Model)


### * Bit-Frequency Analysis

We count how often 0 and 1 appear across all measurements.
True randomness should give roughly 50% zeros and 50% ones — any large imbalance signals bias.


## 3. Mitigating Noise 
Real quantum hardware isn’t perfect and certain qubits might slightly favor 0 or 1. (due to noise)
To correct for that, we use readout-error mitigation:

1. Calibrate a readout matrix A, where each entry A[i][j] gives the probability of reading result j when i was expected.
2. Use it to correct the observed probabilities:

<img src="https://latex.codecogs.com/svg.image?\bg_white%20p_%7Bideal%7D%20=%20A%5E%7B-1%7D%20%5Ctimes%20p_%7Bnoisy%7D" alt="Ideal vs noisy probability vector" />

Simplified from Nath et al. (2025), which builds on Nation et al. (2021) and Ferracin et al. (2024).
This step, also based on IBM’s M3 (Matrix Measurement Mitigation) library, flattens the histogram and improves fairness.

## 4. Password Mode (Application of QRNG)
We map our quantum-generated bits to printable characters (letters, digits, and symbols) to create secure, random passwords.

Example:
Quantum bits → Base94 characters "Y8&f#P2kN@v1"

Each password’s entropy is estimated as:

<img src="https://latex.codecogs.com/svg.image?\bg_white%20Entropy(bits)%20=%20Length%20%5Ctimes%20%5Clog_2(Alphabet%5C%20Size)" alt="Entropy formula" />


So, a 16-character password from 94 symbols ≈ 105 bits of entropy — strong enough to resist brute-force even on quantum-era machines.


This concept expands on the open project “Quantum Password Generator using Qiskit” (https://github.com/SagarPatange/Quantum-Random-Number-Password-Generator) by adding statistical proof and fairness correction.



# D. Data and Results

### 4.1 Bit Frequency
<img width="671" height="494" alt="image" src="https://github.com/user-attachments/assets/7070c6eb-58ee-4ffa-b5c2-b5ccc334d43d" />
Balanced ~50/50 distribution --> confirms superposition fairness.

### 4.2 4-Qubit Counts Histogram
<img width="673" height="497" alt="image" src="https://github.com/user-attachments/assets/ca66532b-db0c-4aea-842d-8f39f73f2821" />

All 16 outcomes (0–15) appear nearly equally, consistent with uniformity.

### 4.3 Uniformity Residuals
<img width="668" height="494" alt="image" src="https://github.com/user-attachments/assets/32790d7d-06fa-4309-8f13-3a02a2b01c89" />

Residuals fluctuate randomly around zero (expected statistical noise only).

### 4.4 LGI Components (Quantum Certification)
<img width="667" height="495" alt="image" src="https://github.com/user-attachments/assets/6a2ee60a-58a4-426c-9ddc-4bd7244a4ecc" />

Obtained K₃ ≈ 1.4 > 1 --> clear **violation** of the classical Leggett–Garg bound (Leggett & Garg, 1985), confirming quantum coherence.

### 4.5 NSIT @ t₂
<img width="669" height="496" alt="image" src="https://github.com/user-attachments/assets/7fe645fd-3193-41e0-bf6c-7f22062a0b04" />

Δ ≈ 0.53 shows measurement at t₁ influences t₂ --> confirms temporal non-classicality (Nath et al., 2025).

### 4.6 Password Entropy vs Length
<img width="668" height="495" alt="image" src="https://github.com/user-attachments/assets/0a308481-3ce9-48cb-9a7e-f2a84db6918c" />

Entropy grows linearly (≈6.55 bits per character for Base94), validating the formula:

<img src="https://latex.codecogs.com/svg.image?\bg_white%20Entropy(bits)%20=%20Length%20%5Ctimes%20%5Clog_2(Alphabet%5C%20Size)" alt="Entropy formula" />





# E. Analysis and Discussion

### A. Quantum Randomness Quality
- **χ² ≈ small, KL ≈ 0.0** → indicates no statistical bias.
- Bit frequencies show perfect 50/50 split across 10k shots.
- Uniformity residuals show natural sampling variation only.

### B. Mitigation Effects
Applying `mitigation.apply_correction()` with calibrated matrix A
reduced small bias due to simulated readout error.
KL divergence decreased post-correction, showing improved fairness.

### C. LGI + NSIT Certification
- **K₃ > 1** confirms temporal correlations inconsistent with classical realism.
- **Δ_NSIT > 0** demonstrates measurement invasiveness (quantum signalling in time).
Together, they provide qualitative evidence that the randomness originates from *non-classical dynamics*, not hidden variables.

### D. Password Generation
- Uniform mapping via rejection sampling ensures unbiased symbol selection.
- Entropy grows linearly, matching the theoretical slope \(≈6.55 bits/char\).
- 16-character Base94 passwords reach **~105 bits entropy** **(secure against brute-force)**.

### E. Implementation Challenges
- **Endianness**: Qiskit’s bitstring ordering had to be handled carefully for LGI/NSIT.
- **Noise simulation**: Real hardware introduces drift — mitigation helps but scales exponentially with qubit count.
- **Reproducibility**: Randomness means every run differs; saving metadata (seed, backend, versions) ensures traceability.



# F. Conclusion

Full-stack quantum random number pipeline:

- True randomness generation from superposition  
- Statistical validation and fairness metrics  
- Noise mitigation for hardware realism  
- Temporal quantum certification (LGI & NSIT)  
- Secure password mapping with entropy guarantees  

The results confirm that even a small Hⁿ circuit produces **statistically fair and quantum-certified randomness** (Herrero-Collantes & García-Escartín, 2017; Nath et al., 2025), applicable for secure cryptographic seeding, simulation, and educational research.





### References:

1. A. J. Leggett and A. Garg, “Quantum Mechanics vs. Macroscopic Realism,” Physical Review Letters 54 (9), 857–860 (1985).
2. M. Herrero-Collantes and J. C. García-Escartín, “Quantum Random Number Generators,” Reviews of Modern Physics 89 (1), 015004 (2017).
3. P. P. Nath, A. Sinha, and U. Sinha, “Certified Randomness on a Quantum Computer,” arXiv preprint arXiv:2502.02973 (2025). https://arxiv.org/html/2502.02973v1
4. P. D. Nation, H. Kang, N. Sundaresan, and J. M. Gambetta, “Scalable Mitigation of Measurement Errors on Quantum Computers,” PRX Quantum 2, 040326 (2021).
5. S. Ferracin, A. Hashim, J.-L. Ville, R. Naik, A. Carignan-Dugas, H. Qassim, A. Morvan, D. I. Santiago, I. Siddiqi, and J. J. Wallman, “Efficiently Improving the Performance of Noisy Quantum Computers,” Quantum 8, 1410 (2024).
6. National Institute of Standards and Technology (NIST), SP 800-22 Rev 1a: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications (2010).
